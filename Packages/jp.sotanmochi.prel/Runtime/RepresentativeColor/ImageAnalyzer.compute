#pragma kernel ClearHistogram
#pragma kernel CalculateIntensityHistogram
#pragma kernel VisualizeHistogram
#pragma kernel CalculateSeparation

#define THREADS_X 16
#define THREADS_Y 16
#define BIN_COUNT 256

Texture2D<float4> SrcTex;
RWStructuredBuffer<uint> Histogram;

RWStructuredBuffer<double> MaxFrequency;
RWStructuredBuffer<double> Threshold;
RWTexture2D<float4> DstTex;

cbuffer params
{
    int SrcWidth;
    int SrcHeight;
    int DstWidth;
    int DstHeight;
};

bool IsValidPixelPosition(uint2 p, uint width, uint height)
{
    return (p.x >= 0 && p.x < width  && p.y >= 0 && p.y < height);
}

[numthreads(BIN_COUNT, 1, 1)]
void ClearHistogram (uint id : SV_DispatchThreadID)
{
    Histogram[id] = 0;
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void CalculateIntensityHistogram (uint2 id : SV_DispatchThreadID)
{
    if (!IsValidPixelPosition(id, SrcWidth, SrcHeight)) { return; }
    
    float Y = dot(SrcTex[id].rgb, float3(0.2126, 0.7152, 0.0722)); // Linear RGB to Grayscale
    
    float max = BIN_COUNT - 1;
    uint bin = (uint)clamp((Y * max), 0, max);
    InterlockedAdd(Histogram[bin], 1);
}

RWStructuredBuffer<double> HistogramAverage;
RWStructuredBuffer<double> SeparationBuffer;

/////////////////////////////////////////////////
// Otsu's method to find the optimal threshold //
/////////////////////////////////////////////////
[numthreads(BIN_COUNT, 1, 1)]
void CalculateSeparation (uint id : SV_DispatchThreadID)
{
    uint threshold = id;
    double m0 = HistogramAverage[0];

    // Class 1
    int n1 = 0; // Pixel count
    double m1 = 0; // Mean
    for (int p = 0; p < threshold; p++)
    {
        n1 += Histogram[p];
        m1 += p * Histogram[p];
    }
    if (n1 == 0)
    {
        m1 = m0;
    }
    else
    {
        m1 = m1 / n1;
    }

    double v1 = 0; // Variance
    for (int p = 0; p < threshold; p++)
    {
        v1 += (p - m1) * (p - m1) * Histogram[p];
    }
    if (n1 == 0)
    {
        v1 = 0.0;
    }
    else
    {
        v1 = v1 / n1;
    }

    // Class 2
    int n2 = 0; // Pixel count
    double m2 = 0; // Mean
    for (int q = threshold; q < BIN_COUNT; q++)
    {
        n2 += Histogram[q];
        m2 += q * Histogram[q];
    }
    if (n2 == 0)
    {
        m2 = m0;
    }
    else
    {
        m2 = m2 / n2;
    }

    double v2 = 0; // Variance
    for (int q = threshold; q < BIN_COUNT; q++)
    {
        v2 += (q - m2) * (q - m2) * Histogram[q];
    }
    if (n2 == 0)
    {
        v2 = 0.0;
    }
    else
    {
        v2 = v2 / n2;
    }

    double var_in = (n1*v1 + n2*v2) / (n1 + n2);
    double var_bw = (n1*(m1 - m0)*(m1 - m0) + n2*(m2 - m0)*(m2 - m0)) / (n1 + n2); 

    SeparationBuffer[threshold] = var_bw / var_in;
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void VisualizeHistogram (uint2 id : SV_DispatchThreadID)
{
    if (!IsValidPixelPosition(id, DstWidth, DstHeight)) { return; }
    
    uint bin = (uint)clamp((float) id.x / DstWidth * BIN_COUNT, 0, BIN_COUNT - 1);
    uint normalizedFrequency = (uint)((float) Histogram[bin] / MaxFrequency[0] * DstHeight);
    
    // if (id.y < normalizedFrequency) { DstTex[id] = float4(1, 1, 1, 1); }
    // else { DstTex[id] = float4(0, 0, 0, 1); }
    
    DstTex[id] = (id.y < normalizedFrequency) ? float4(1, 1, 1, 1) : float4(0, 0, 0, 1);
    
    if (bin == (uint)Threshold[0]) { DstTex[id] = float4(1, 0, 0, 1); }
}