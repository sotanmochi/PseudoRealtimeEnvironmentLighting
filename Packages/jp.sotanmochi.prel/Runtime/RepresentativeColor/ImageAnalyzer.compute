#pragma kernel ClearHistogram
#pragma kernel CalculateIntensityHistogram
#pragma kernel VisualizeHistogram

#define THREADS_X 16
#define THREADS_Y 16
#define BIN_COUNT 256

Texture2D<float4> SrcTex;
RWStructuredBuffer<uint> Histogram;

RWStructuredBuffer<double> MaxFrequency;
RWStructuredBuffer<double> Threshold;
RWTexture2D<float4> DstTex;

cbuffer params
{
    int SrcWidth;
    int SrcHeight;
    int DstWidth;
    int DstHeight;
};

bool IsValidPixelPosition(uint2 p, uint width, uint height)
{
    return (p.x >= 0 && p.x < width  && p.y >= 0 && p.y < height);
}

[numthreads(BIN_COUNT, 1, 1)]
void ClearHistogram (uint id : SV_DispatchThreadID)
{
    Histogram[id] = 0;
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void CalculateIntensityHistogram (uint2 id : SV_DispatchThreadID)
{
    if (!IsValidPixelPosition(id, SrcWidth, SrcHeight)) { return; }
    
    float Y = dot(SrcTex[id].rgb, float3(0.2126, 0.7152, 0.0722)); // Linear RGB to Grayscale
    
    float max = BIN_COUNT - 1;
    uint bin = (uint)clamp((Y * max), 0, max);
    InterlockedAdd(Histogram[bin], 1);
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void VisualizeHistogram (uint2 id : SV_DispatchThreadID)
{
    if (!IsValidPixelPosition(id, DstWidth, DstHeight)) { return; }
    
    uint bin = (uint)clamp((float) id.x / DstWidth * BIN_COUNT, 0, BIN_COUNT - 1);
    uint normalizedFrequency = (uint)((float) Histogram[bin] / MaxFrequency[0] * DstHeight);
    
    // if (id.y < normalizedFrequency) { DstTex[id] = float4(1, 1, 1, 1); }
    // else { DstTex[id] = float4(0, 0, 0, 1); }
    
    DstTex[id] = (id.y < normalizedFrequency) ? float4(1, 1, 1, 1) : float4(0, 0, 0, 1);
    
    if (bin == (uint)Threshold[0]) { DstTex[id] = float4(1, 0, 0, 1); }
}